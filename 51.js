// 虚拟dom
// 什么是虚拟 DOM

// 本质上是 JavaScript 对象 这个对象就是更加轻量级的对 DOM 的描述

// 为什么要有虚拟 DOM
// react最最初考虑dom操作api很复杂，操作很多，最初是整体刷新页面，但是这种方式很慢，然后就改变方式，对比没有改变的地方保持不动，只有有变动的地方才更新
// DOM 是树形结构 所以 diff 算法必须是针对树形结构的 目前已知的完整树形结构 diff 算法复杂度为 O(n^3)
// 但是时间复杂度 O(n^3) 太高了
// DOM 是复杂的，对它的操作（尤其是查询和创建）是非常慢非常耗费资源的
// 对于 DOM 这么多属性，其实大部分属性对于做 Diff 是没有任何用处的，所以如果用更轻量级的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作
// 过程：
// 维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应
// 前后两个 Virtual DOM 做 diff ，生成变更（Mutation）
// 把变更应用于真实 DOM，生成最新的真实 DOM
// 因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。

// React 厉害的地方并不是说它比 DOM 快，而是说不管你数据怎么变化，我都可以以最小的代价来进行更新 DOM。
// 框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护
// 没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。
// Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。

// Vue 采用虚拟 DOM 的原因是什么呢
// 我们知道vue与react不同，vue采用数据劫持的方式，不需要diff就可以知道精确的变化，
// vue 2.0 引入 vdom 的主要原因是 vdom 把渲染过程抽象化了，
// 从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标？？？？？

// 虚拟 DOM 的缺点
// 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢
// 虚拟 DOM 需要在内存中的维护一份 DOM 的副本
// 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。
// 所以，如果你有一个 DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。
// 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。

// diff算法
// 计算一棵树形结构转换成另一棵树形结构的最少操作，传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中n是树中节点的总数
// React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题

// diff 策略
// Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 tree diff 即对树进行分层比较，两棵树只会对同一层次的节点进行比较
// 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 component diff 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点
// 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 element diff


// react hooks

// 函数组件和类组件有什么不同？
// 有hooks之前 Class组件实现了更多的React特性(如:生命周期、state、ref)，这是Function 组件没有实现的
// 函数组件每次渲染都拥有独立的props，这是因为在react中props是不可变的。每次重新render，函数都捕获到新的独立的props

// 为什么只能在函数组件的最顶层使用hooks