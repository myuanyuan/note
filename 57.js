// 静态资源优化

// 减少不必要的请求 延迟加载的内容异步加载 可以合并的资源进行资源合并
// 减少包体大小 使用适合当前资源的压缩技术 gzip 避免再响应包体里“塞入”一些不需要的内容
// 降低应用资源时的消耗
// 利用缓存


// 重排和重绘

// 回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：

// 添加或删除可见的DOM元素
// 元素的位置发生变化
// 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
// 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
// 页面一开始渲染的时候（这肯定避免不了）
// 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

// 浏览器的优化机制

// 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。
// 浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：

// offsetTop、offsetLeft、offsetWidth、offsetHeight
// scrollTop、scrollLeft、scrollWidth、scrollHeight
// clientTop、clientLeft、clientWidth、clientHeight
// getComputedStyle()
// getBoundingClientRect

// 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。

// 批量修改DOM
// 使用cssText
// 修改CSS的class


// 使元素脱离文档流
// 对其进行多次修改
// 将元素带回到文档中

// 让DOM脱离文档流
// 隐藏元素，应用修改，重新显示
// 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档
// 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素
// 对于复杂动画效果,使用绝对定位让其脱离文档流