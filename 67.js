// dom 渲染 机制
// 首先我们需要了解的一点就是，在浏览器渲染页面之前，它需要通过解析HTML标记然后构建DOM树。在这个过程中，如果解析器遇到了一个脚本(script)，它就会停下来，并且执行这个脚本，然后才会继续解析HTML。如果遇到了一个引用外部资源的脚本(script)，它就必须停下来等待这个脚本资源的下载，而这个行为会导致一个或者多个的网络往返，并且会延迟页面的首次渲染时间。

// 还有一点是需要我们注意的，那就是外部引入的脚本(script)会阻塞浏览器的并行下载，HTTP/1.1规范表明，浏览器在每个主机下并行下载的组件不超过两个(也就是说，浏览器一次只能够同时从同一个服务器加载两个脚本)；如果你网站的图片是通过多个服务器提供的，那么按道理来说，你的网站可以一次并行下载多张图片。但是，当我们网站在加载脚本的时候；浏览器不会再启动任何其它的下载，即使这些组件来自不同的服务器。

// 还是有一些情况需要我们在头部引用脚本的；到底是哪些情况需要我们这么做呢：
// 这些脚本需要在浏览器渲染页面之前就执行的
// 如果你的脚本中使用了document.write在页面中插入内容的话，那就不能够将这条脚本放置到文档的底部了

// async属性
// 这个属性是HTML5给script新添加的属性，而且只适用于外部的JavaScript文件，如果在script标签上添加了这个属性，那么表明这个脚本资源就不再是同步加载的了，而是异步加载的，所以不会阻塞浏览器对页面的渲染。当然这个属性会存在一些兼容性问题，一些浏览器还未实现对这个属性的支持。


// 当解析HTML时遇到内联JS代码，会阻塞DOM树的构建
// 特别悲惨的情况： 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时！！！根据浏览器的安全解析策略，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。

// 解析html头部代码 -》下载css/js资源 =》 继续解析html 构建dom树 =》js会阻塞html的解析 所以js尽量不要放在头部 =》如果有交互部分的代码要放在头部最好放在css上边 因为css渲染后才能看到交互效果

// 加载JavaScript文件的最佳实践

// 1. 对于必须要在DOM加载之前运行的JavaScript脚本，我们需要把这些脚本放置在页面的head中，而不是通过外部引用的方式，因为外部的引用增加了网络的请求次数；并且我们要确保内敛的这些JavaScript脚本是很小的，最好是压缩过的，并且执行的速度很快，不会造成浏览器渲染的阻塞。

// 2. 对于支持使用script标签的async和defer属性的浏览器，我们可以使用这两个属性；其中需要注意的点就是，async表示的意思是异步加载JavaScript文件，它的下载过程可以在HTML的解析过程中进行，加载完成之后立即执行这个文件的代码，执行文件代码的过程中会阻塞HTML的解析，它不保证文件加载的顺序。defer表示的意思是在HTML文档解析之后在执行加载完成的JavaScript文件，JavaScript文件的下载过程可以在HTML的解析过程中进行，它是按照script标签的先后顺序来加载文件的。

//  由于1&&2 使用async属性确保两者之间互不依赖非常重要。概括来讲，就是这两个属性都会使script标签异步加载，然而执行的时机是不一样的

// 浏览器下载、解析、渲染页面优化
// 尽可能的精简HTML的代码和结构
// 尽可能的优化CSS文件和结构
// 一定要合理的放置JS代码，尽量不要使用内联的JS代码

// css加载会造成阻塞吗？
// js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗？
//  CSS 加载不会阻塞 DOM 的解析，但是CSS 加载会阻塞 Dom 的渲染 样式表会在后面的 js 执行前先加载执行完毕

// 性能优化
// 加载优化（最耗时）
// 减少 HTTP 请求：浏览器一般同时响应请求为4个请求（PC 一般为4个，Android 支持4个，IOS 5后可支持6个），所以尽量减少页面的请求数，首次加载同时请求数不能超过4个。
// 合并 CSS、 JavaScript；
// 合并小图片、 使用 CSS sprite，base-64；
// 缓存：使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长 Cache （长 Cache 资源的更新可使用时间戳）
// 缓存一切可缓存的资源；
// 使用外联式引用 CSS、JavaScript（可使用 localstorage 缓存图片）
// 压缩 HTML、CSS、JavaScript：减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript 等进行代码压缩，并在服务端设置 GZip
// 使用首屏加载：首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化；
// 按需加载：将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量。但是这也会导致大量重绘，影响渲染性能
// LazyLoad
// 滚屏加载
// 通过 Media Query 加载
// 预加载：大型重资源页面（如游戏）可使用增加 Loading 的方法，资源加载完成后再显示页面。但 Loading 时间过长，会造成用户流失。
// 对用户行为分析，可以在当前页加载下一页资源，提升速度
// 图片压缩：图片是最占流量的资源，因此尽量避免使用它，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小。
// 使用 智图 压缩；
// 使用其他方式代替图片（CSS3，SVG，IconFont）；
// 选择合适的图片（webP优于JPG，PNG8优于GIF）；
// 选择合适的大小（首次加载不大于1014KB，不宽于640（基于手机的一般宽度））；

// http 1.0 2.0 http2 https

// HTTP1.0和HTTP1.1的一些区别
// 1. 缓存处理 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match
// 2. 带宽优化及网络连接的使用 htpp1.0 不支持断点续传功能 HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206
// 3.错误通知的管理 在HTTP1.1中新增了24个错误状态响应码 410（Gone）表示服务器上的某个资源被永久性的删除
// 4. Host头处理 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址 HTTP1.1的请求消息和响应消息都应支持Host头域
// 5. 长连接 HTTP 1.1支持长连接 在一个TCP连接上可以传送多个HTTP请求和响应 在HTTP1 .1中默认开启Connection： keep-alive

// HTTPS与HTTP的一些区别
// 1. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
// 2. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

// HTTP2.0
// 1. HTTP2 采用二进制数据帧传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效
// 2. HTTP2.0 支持多路复用 请求的都是通过一个 TCP 连接并发完成
// 3. HTTP2.0使用encoder来减少需要传输的header大小 即进行了header压缩
// 4. 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能

// Keep-Alive的问题
// 串行的文件传输
// 同域并行请求限制带来的阻塞（6~8）个

// 前端性能监控
// 利用 window.performance.timing
// 白屏时间：从浏览器输入地址并回车后到页面开始有内容的时间；
// 首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间；
// 首屏时间 = 白屏时间 + 首屏渲染时间

// 前端性能优化之白屏时间
// 白屏过程 dns解析 tcp链接 服务器响应
// 客户端下载、解析、渲染显示页面
// 如果是Gzip包，则先解压为HTML
// 解析HTML的头部代码，下载头部代码中的样式资源文件或脚本资源文件
// 解析HTML代码和样式文件代码，构建HTML的DOM树以及与CSS相关的CSSOM树
// 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树
// 白屏时间 = domloading - fetchStart

// const stack1 = [];
// const stack2 = [];

// function push(k) {
//   if (!stack1.length) {
//     stack1.push(k);
//   } else {
//     while (stack1.length) {
//       stack2.push(stack1.pop())
//     }
//     stack1.push(k);
//     while (stack2.length) {
//       stack1.push(stack2.pop())
//     }
//   }
// }
// function pop() {
//   return stack1.pop();
// }

// 输出结果：
// push(1);
// push(2);
// console.log(pop()); // 1
// push(3);
// console.log(pop()); // 2
// console.log(pop()); // 3


// 请通过promise和数组reduce方法实现链式调用
// 现有数组arr，arr中包含n个函数。
// 函数会返回promise。要求通过promise和数组reduce方法实现链式调用。

// function fn(arr) {
//   arr.reduce(async function (pre, cur) {
//     await pre;
//     return cur;
//   })
// }

// let arr = [];
// for (let i = 0; i < 10; i++) {
//   arr.push(() => new Promise((resolve) => {
//     console.log(i);
//     resolve();
//   }))
// }
// fn(arr)


// 编写闭包函数实现加法器
// 加法器定义为：
// add(1)() => 1
// add(1)(2)(3)(4)() => 10

// function add(num) {
//   let sum = 0;
//   sum += num;
//   return function (n) {
//     if (n) {
//       sum += n;
//       return add(sum);
//     } else {
//       return sum;
//     }
//   }
// }
// console.log(add(1)());

// console.log(add(1)(2)(3)(4)());


// 自我介绍
// 你好，我是苗园园 毕业于洛阳师范学院 大学专业是物理学，16年开始学习前端编程的， 从业之后项目中使用过的技术栈包括 jquery vue1.0 vue2.0 react等
// 曾在三家公司工作，第一份是在一家做母婴电商的公司，主要负责内容部分的业务，使用vue1.0 和vue2.0。
// 第二家是一家做遥感数据可视化的公司，主要负责toB的项目，使用react，另外使用antd 和 echart
// 第三家也就是现在这家就是58同城，主要负责招聘业务线的部分前端开发，包括toC企业点评，toB的会员成长体系，还有一些运营项目，技术栈大部分是react，少部分是vue。

// 项目中遇到的难点/挑战
// 如何让别人很愉快的听懂我说的话
// 我向面试官说的所有的话，都是成体系的。
// 我向面试官说的所有的话，都是逻辑清晰的。
// 我向面试官说的所有的话，我都先停顿两秒以上，思考清楚了再说话。
// 刚才您说的问题，我来描述一遍xxxxxxx。描述完之后，你再问面试官，您表达的是这个意思吗？

// 必会的面试题目
// 1. 前端浏览器输入URL后发生什么？
// dns解析，获取html文件，解析DOM，渲染页面这么一个流程。
// 其实过程复杂的很，比如一个dns解析阶段，它分为哪几步？解析的ip一定是一样的吗？每次都会进行dns解析吗？可能还需要了解cdn托管的一些问题。
// 比如html文件获取，它是如何传输的？如何建立链接的？三次握手、四次挥手是什么？http协议端口是什么？为什么直接能访问一个html文件？

// 2. 前端性能优化？
// 大多数前端，基本会说，减少http请求、压缩合并js以及css、图片懒加载的技术、防止回流和重绘、css放头部、js放底部。
// 比如减少http请求，可以从哪些维度上减少呢？
// 比如合并http请求？
// 比如合并资源？
// 比如图片懒加载？
// http还有其他维度的优化吗？
// cookie优化？
// http请求和资源加载的区分优化？
// 在webview中呢？和普通的浏览器的优化技术，又有什么区别？

// 3. 前端如何做性能监控、异常监控？
// 性能监控，异常监控，基本在小公司，是没有实践基础的，可是在差不多的大厂中，他们会关注这个问题。
// 首先是性能监控，应该从这么几个维度来说：
// 一个是http的方面，在后端log日志，流入kafka，然后在kafka消费数据，可以准确的监控到哪些接口有异常？异常率是多少？
// 另一个方面，是前端的 Performance 的api，在用户的实时使用的过程中，就会产生数据，这样就能实现页面性能监控。

// 前端异常监控，首先要明白什么是异常，html、css这些东西，无非就是一个展示的问题，还不至于让页面白屏的事情发生，所谓的异常监控，其实就是js的异常监控。
// 在前端领域，window.onerror是进行js异常的监听事件。
// 并且要知道，它在IE中，是不支持的，所以IE的监控，要使用try catch 的方式进行捕获，比如我们可能还要注意到，遇到异步的时候，这个如何做try catch的异常捕获。
// 最后一个是前端sdk埋点，直接开发一个js文件，统计用户的UV/PV分析等等，比如用户的转化率之类的。

// 4. 前端安全方面

// 我们必须理解这么几个方面：sql注入、xss、csrf、cookie安全、密码安全等等。
// sql注入，要理解sql注入的场景，它的原理是什么，当前的数据库的解决方案是什么？
// xss攻击，常见的攻击场景，什么类型的网站容易被xss攻击，整个流程的原理是什么？
// csrf攻击，其实就是一个钓鱼网站，要理解为什么会收到攻击，应该采取什么策略进行防御。
// cookie安全，要理解为什么用token，优势等。
// 密码安全，主要是用户登陆，用户数据提交，加密，存入数据库的一整个流程。
// 其实还有http和https的问题等等

// 5. http、https、http1.0、1.1、2.0、3.0的区别

// http进行非对称加密，得到https，这个过程是怎么样的？什么是CA证书？整个网站进行验证的流程是什么？
// http各个版本的区别是什么？
// 解决了哪些问题？
// 比如头部缩减的优化，那你了解这个优化的具体策略吗？
// 缩减了什么？又增加了什么？

// http的底层协议？
// tcp/ip协议的三次握手，四次挥手，具体是怎么通信的？
// 什么叫满启动？
// 甚至延伸到整个网络协议的领域，什么是socket？
// udp是干什么的？dns解析？ftp？
// 以及不常用的其他协议？

// 深度解读
// 1. 源码 todo
// 2. 可视化 地图、echats、canvas、webgl、d3.js、three.js！
// 3. 跨平台 flutter、react-native、weex、electron  electron，就是要理解它的本质，就是使用node塑造一个桌面应用的容器，然后内部是一个webview。


// 4. 工程化
// 1、前端项目标准？
// 表现为库的选择？文件划分目录的规定？pc、mobile多端实践？ssr方案集成？
// 2、组件库集成？
// 组件库建设的目的？npm包的发布？
// 3、脚手架工具？
// webpack编译优化？webpack打包构建优化？自我脚手架的工具使用？
// 4、git提交规范commit-msg？代码检查规范eslint？
// 5、前端性能监控？前端异常监控？前端用户埋点sdk？
// 6、rap？jenkins？

// 5、混合app交互
// jsBridge、性能提升方面、x5内核
// 算是一个小的模块吧，我们得明白，jsBridge是如何做到h5和原生应用的交互？
// ios和h5的交互通信？window.webkit?是否同步？
// android和h5的交互？细节和ios有什么不同？
// webview在性能提升方面，可以做哪些？什么是离线包？
// 腾讯x5内核的优势是什么？我们用了x5内核，可以避免什么问题？

// 6、设计模式
// 最后谈谈设计模式，算是一个高频的面试题。
// 我们至少要知道以下这些设计模式的功能、代码实现、使用场景问题。
// 单例模式、原型模式、工厂模式、观察者模式、策略模式、代理模式等等


// https 加密
// 客户端与服务器建立连接后，各自生成私钥和公钥。服务器返给客户端一个公钥，客户端拿着公钥把要传输的内容进行加密，连同自己的公钥一起返给服务器，服务器用自己的私钥解密密文，然后把响应的数据用客户端公钥加密，再返给客户端，客户端用自己的私钥解密密文，完成数据的展现


// HTTPS加密过程：
// 客户端请求服务器获取 证书公钥
// 客户端(SSL / TLS)解析证书（无效会弹出警告）
// 生成随机值
// 用 公钥加密随机值生成密钥
// 客户端将 秘钥 发送给服务器
// 服务端用私钥解密秘钥 得到随机值
// 将信息和随机值混合在一起 进行对称加密
// 将加密的内容发送给客户端